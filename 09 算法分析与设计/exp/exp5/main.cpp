// main.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//

#include <iostream>
#include <algorithm>
#include <string>

using namespace std;

const double Punishment = -100;
const double Reward = 100;
const double gamma = 0.9;

// 新建转移概率矩阵
// 四块儿分别对应，上，下，左，右。即P = P[a][s][s']
// 上:0，下:1，左:2，右:3
const double P[4][11][11] = {
    {{0.15, 0.8,	0,	0.05,	0,	0,	0,	0,	0,	0,	0},
    {0, 0.2,	0.8,	0,	0,	0,	0,	0,	0,	0,	0},
    {0,	0,	0.95,	0,	0.05,	0,	0,	0,	0,	0,	0},
    {0.05,	0,	0,	0.9,	0,	0.05,	0,	0,	0,	0,	0},
    {0,	0,	0.05,	0,	0.9,	0,	0,	0.05,	0,	0,	0},
    {0,	0,	0,	0.05,	0,	0.1,	0.8,	0,	0.05,	0,	0},
    {0,	0,	0,	0,	0,	0,	0.15,	0.8,	0,	0.05,	0},
    {0,	0,	0,	0,	0.05,	0,	0,	0.9,	0,	0,	0.05},
    {0,	0,	0,	0,	0,	0.05,	0,	0,	0.15,	0.8,	0},
    {0,	0,	0,	0,	0,	0,	0,	0,	0,	1,	0},
    {0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	1}},

    {{0.95,	0,	0,	0.05,	0,	0,	0,	0,	0,	0,	0},
    {0.8,	0.2,	0,	0,	0,	0,	0,	0,	0,	0,	0},
    {0,	0.8,	0.15,	0,	0.05,	0,	0,	0,	0,	0,	0},
    {0.05,	0,	0,	0.9,	0,	0.05,	0,	0,	0,	0,	0},
    {0,	0,	0.05,	0,	0.9,	0,	0,	0.05,	0,	0,	0},
    {0,	0,	0,	0.05,	0,	0.9,	0,	0,	0.05,	0,	0},
    {0,	0,	0,	0,	0,	0.8,	0.15,	0,	0,	0.05,	0},
    {0,	0,	0,	0,	0.05,	0,	0.8,	0.1,	0,	0,	0.05},
    {0,	0,	0,	0,	0,	0.05,	0,	0,	0.95,	0,	0},
    {0,	0,	0,	0,	0,	0,	0,	0,	0,	1,	0},
    {0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	1}},

    {{0.95,	0.05,	0,	0,	0,	0,	0,	0,	0,	0,	0},
    {0.05,	0.9,	0.05,	0,	0,	0,	0,	0,	0,	0,	0},
    {0,	0.05,	0.95,	0,	0,	0,	0,	0,  0,	0,	0},
    {0.8,	0,	0,	0.2,	0,	0,	0,	0,	0,	0,	0},
    {0,	0,	0.8,	0,	0.2,	0,	0,	0,	0,	0,	0},
    {0,	0,	0,	0.8,	0,	0.15,	0.05,	0,	0,	0,	0},
    {0,	0,	0,	0,	0,	0.05,	0.9,	0.05,	0,	0,	0},
    {0,	0,	0,	0,	0.8,	0,	0.05,	0.15,	0,	0,	0},
    {0,	0,	0,	0,	0,	0.8,	0,	0,	0.15,	0.05,	0},
    {0,	0,	0,	0,	0,	0,	0,	0,	0,	1,	0},
    {0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	1}},

    {{0.15,	0.05,	0,	0.8,	0,	0,	0,	0,	0,	0,	0},
    {0.05,	0.9,	0.05,	0,	0,	0,	0,	0,	0,	0,	0},
    {0,	0.05,	0.15,	0,	0.8,	0,	0,	0,	0,	0,	0},
    {0,	0,	0,	0.2,	0,	0.8,	0,	0,	0,	0,	0},
    {0,	0,	0,	0,	0.2,	0,	0,	0.8,	0,	0,	0},
    {0,	0,	0,	0,	0,	0.15,	0.05,	0,	0.8,	0,	0},
    {0,	0,	0,	0,	0,	0.05,	0.1,	0.05,	0,	0.8,	0},
    {0,	0,	0,	0,	0,	0,	0.05,	0.15,	0,	0,	0.8},
    {0,	0,	0,	0,	0,	0,	0,	0,	0.95,	0.05,	0},
    {0,	0,	0,	0,	0,	0,	0,	0,	0,	1,	0},
    {0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	1}},
};

//double calExpect(const double* A) {
//    return A[10] * Reward + A[9] * Punishment;
//}

//double vectorMul(const double* A, double* B) {
//    double sum = 0;
//    for (int i=0; i < 11; i++) {
//        sum += A[i] * B[i];
//    }
//    return sum;
//}

int argmax(double* Q) {
    int index = 0;
    double max = Q[0];//感觉怪怪的，和同学讨论之后发现这里有问题，就改了 
    for (int i = 0; i < 4; i++) {
        if (Q[i] > max) {
            max = Q[i];
            index = i;
        }
    }
    return index;
}

// 将action_value翻译成汉字
string translate(int index) {
    switch (index) {
    case 0:
        return string("上");
    case 1:
        return string("下");
    case 2:
        return string("左");
    default:
        return string("右");
    }
}

int main()
{   
    /* 值迭代 */
    double V[11]={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    double Q[11][4]={ 0 };
    
    
    
    
    
    
    /*请在此处补全值迭代的代码
    * 
    */
    //已补全 
    //初始化，m是迭代次数 
    	int i,j,k,m,judge;
		m=0; 
		judge=1;
	    double V1[11]= {0};
	    double temp;
	    while(judge){
	    	for(i=0;i<11;i++)
				V1[i]=V[i];//更新V1数组 
	    	for(i=0;i<11;i++){
	    		for(j=0;j<4;j++){
	    			temp=0;
	    			for(k=0;k<11;k++){
	    				temp=temp+gamma*P[j][i][k]*V[k];
	    			}
	    			//9和10是因为状态和i差一位 
	    			Q[i][j]=temp+P[j][i][10]*Reward+P[j][i][9]*Punishment;
	    		}
	    	}
	    	for(i=0;i<11;i++){
	    		V[i]=Q[i][argmax(Q[i])] ;
	    	}
	    	m++;
	    	judge=0;
			for(i=0;i<11;i++){
				if(V[i]!=V1[i]){
					//没有收敛，需要继续 
					judge= 1;
				}
			} 
	    } 
    
    
    
    
    
    
    cout<<"迭代次数：  "<<m<<'\n'; 
    cout << "Reward = " << Reward <<  " , " <<" Punishment = " << Punishment << endl;
    cout << "值迭代： " << endl;
    cout << "状态" << "\t" << " " << "\t" << "价值" << endl;
    for (int s = 0; s < 11; s++) {
        cout << s+1 << "\t" <<" : " << "\t" << V[s] << endl;
    }
    cout << "---------------------------------------------" << endl;
    //Print Policy
    cout << "状态" << "\t" << " " << "\t" << "动作" << endl;
    for (int s = 0; s < 9; s++) {
        cout << s+1 << "\t" << " -> " << "\t" <<translate(argmax(Q[s])) <<endl;
    }
    cout << "---------------------------------------------" << endl;


    /* 策略迭代 */
    printf("\n\n\n\n\n");
    int pi[11] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    double V_2[11] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
	
	
	
	
	
	/*请在此处补全策略迭代的代码
    * 
    */
    //已补全 
		printf("\n\n\n\n\n");
	    double delta;
	    int new_pi;
		judge=1;
	    m=0;
	    while(judge){
	    	//策略评估 
	    	delta=0;
			//初始化 
	    	while(1){
	    		delta=0;
	    		for(i=0;i<11;i++){
	    			V1[i]=V_2[i];
	    			temp=0;
	    			for(k=0;k<11;k++){
	    				temp=temp+gamma*P[pi[i]][i][k]*V_2[k];
	    			}
	    			V_2[i]=temp+ P[pi[i]][i][10]*Reward+P[pi[i]][i][9]*Punishment;
	    			if(V_2[i]-V1[i]>0)
						delta=delta>(V_2[i]-V1[i])?delta:(V_2[i]-V1[i]);
					else
						delta=delta>(V1[i]-V_2[i])?delta:(V1[i]-V_2[i]);
	    		}
	    		if(delta<5){
	    			//收敛了，停止 
					break; 
				}
	    	}
	    	//策略提升 
			for(i=0;i<11;i++){
				for(j=0;j<4;j++){
	    			temp=0;
	    			for(k=0;k<11;k++){
	    				temp=temp+gamma*P[j][i][k]*V_2[k];
	    			}
		    		//9和10是因为状态和i差一位 
	    			Q[i][j]=temp+P[j][i][10]*Reward+P[j][i][9]*Punishment;
	    		}
	    	}
	    	for(i=0;i<11;i++){
	    		new_pi=argmax(Q[i]);
	    		if(pi[i]!=new_pi){
	    			//不收敛 
	    			pi[i]=new_pi;
	    		}
	    	}
	    	judge= 0;
			for(i=0; i<11; i++){
				if(V_2[i] != V1[i])
					judge= 1;
			} 
	    	m++;
	    } 
    
    
    
    
    
    
    
    cout<<"迭代次数：  "<<m<<'\n'; 

    cout << "策略迭代： " << endl;
    cout << "状态" << "\t" << " " << "\t" << "价值" << endl;
    for (int s = 0; s < 11; s++) {
        cout << s + 1 << "\t" << " : " << "\t" << V_2[s] << endl;
    }

    cout << "---------------------------------------------" << endl;
    cout << "状态" << "\t" << " " << "\t" << "动作" << endl;
    for (int s = 0; s < 9; s++) {
        cout << s + 1 << "\t" << " -> " << "\t" << translate(pi[s]) << endl;
    }

    return 0;
}

