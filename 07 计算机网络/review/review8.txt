8 传输层(OSI的机制和Internet的应用)

8.1 传输层服务
    TSAP
        Transport Service Access Point
        传输层服务访问点
    NSAP
        Network Service Access Point
        网络层服务访问点
    目的
        实现用户对数据传输控制
            网络层在用户终端和路由器上, 传输层在用户主机上
            用户根据需求可选不同的传输层服务(无连接或面向连接的服务)
        实现运行在不同主机上进程之间通信
            每个应用进程至少与一个传输层地址(端口)对应
        屏蔽下层网络异质性
            对上层应用提供了标准的原语集合, 提供传输层虚拟管道
            原语是上层访问下层服务的标准接口, 每种传输服务都有各自的原语

8.2 传输层寻址
    传输层为上层提供复用机制, 因此进程间建立连接时, 需要指明传输层TSAP地址
    TSAP获取方法
        周知端口
            少数关键服务在周知端口(知名端口)上
        进程服务器
            每个系统都有进程服务器, 服务器绑定周知端口
            用户进程为了与目标进程通信, 先和进程服务器通信
            进程服务器启动目标服务进程
        名字服务器
            新服务创建, 必须向名字服务器注册
            注册内容包含服务名和TSAP等
            用户进程在名字服务器中查找相应服务
    NSAP和TSAP标识了一个主机的进程, 是ISO定义的概念
    在Internet中, NSAP对应IP地址, TSAP对应端口号
    {IP地址, 端口号, 协议类型}标识主机上的服务用户进程
    {源IP地址, 源端口号, 目的IP地址, 目的端口号, 协议类型}传输服务数据流

8.3 建立连接
    CR
        Connect Request
        连接请求
    DR 
        Disconnect Request 
        断开连接请求
    无连接的服务
        传输层可以选择无连接的服务
    面向连接的服务
        传输层为了给上层提供可靠传输服务时, 需协商参数保证可靠性
        本质上是在收发两端维持可靠传输的参数状态
        对面向连接的传输层, 发之前要先建立连接
        建立连接方法, 三次握手(发送TPDU)
            主机1选择序列号x, 向主机2发含该序列号的连接请求CR
            主机2选择序列号y, 向主机1发含应答接受连接含x和y的ACK
            主机1使用序列号x, 向主机2发含序列号x和y以及要发送的Data
            若主机超时的CR突然出现到达对方, 则主机收到ACK后发含y的Reject
        释放连接方法(发送TPDU)
            非对称释放
                连接的任何一方都可断开连接
                某一端主机发送DR当即主机断开连接
                对方收到后也立即断开
                此时在路上的数据会丢失
            对称释放, 四次挥手
                连接是两个独立的单向连接, 需要分别释放
                某一主机发送DR请求断开连接, 该主机不再发送其他数据
                对方收到后回应DR请求断开连接, 该主机不再发送其他数据
                主机收到DR后立即断开连接, 并回应ACK
                对方收到ACK后立即断开连接
            若出现超时, 则尝试一定次数之后直接释放断开连接
        面向连接的服务提供了流量控制和拥塞控制
            核心是滑动窗口机制
            流量控制
                根据接收端缓存容量动态调整发送端窗口大小
                防止快速发送淹没慢速接收
            拥塞控制
                根据网络的承载容量动态调整发送端窗口大小
                防止发送端数据超过网络容量
                拥塞发生在路由器上, 但根本原因是各节点发送流量多引起的
                网络层无连接无法控制速率, 唯一控制方法是传输层放缓发送速率
                拥塞控制是网络层和传输层共同责任

8.4 Internet的传输层协议
    UDP
        User Datagram Protocol
        用户数据报协议
    TCP
        Transmission Control Protocol
        传输控制协议
    SCTP 
        Stream Control Transmission Protocol
        流控制传输协议
    MPTCP
        Multi Path Transmission Control Protocol
        多路传输控制协议
    QUIC
        Quick User datagram protocol Internet Connection
        快速用户数据报网络连接
    MSS 
        Maximum Segment Size
        最大报文段长度
    RTT 
        Round Trip Time
        往返时延
    RWND
        Receiver WiNDow
        接收端窗口 
    CWND
        Congestion WiNDow
        拥塞窗口
    SWND 
        Sender WiNDow
        发送端窗口
    SSTHRESH
        Slow Start THRESHold
        慢启动阈值
    两个常用的Internet的传输层协议
        UDP TPDU为数据报datagram
            无确认无连接, 简单有效但是不可靠
        TCP TPDU为数据段segment
            面向连接的服务, 可靠但是流量开销大
    其他传输层协议, 有SCTP, MPTCP, QUIC等
    端口分知名端口和一般端口, 端口号16bit, 知名端口0到1023
    部分知名端口号
        20/TCP FTP主动数据
        21/TCP FTP命令
        25/TCP SMTP 
        53/UDP DNS
        80/TCP WWW
        110/TCP POP3
    端口标识应用进程, 数据中的端口号由程序或系统指定
    IP地址标识Internet的主机, 数据中的IP地址由程序或系统指定
    MAC地址标识链路上接口设备, 数据中的MAC地址由系统指定
    数据在网络中传输时, 端口和IP不变, 但是MAC会变化
    UDP
        简单高效
        客户服务器模式应用, 如DNS
        话音, 视频等实时多媒体应用
        帧格式
            2B 2B 2B  2B  nB
            SP DP Len Cks Data
        SP 
            源端口号
        DP 
            目的端口号
        Len 
            整个UDP帧长度
        Cks
            整个UDP数据帧的16位校验和
            计算时需要添加一个虚的伪IP头标进行
            伪头标
                4B 4B 1B  1B  2B
                SI DI Res Ptc Len
            SI
                发送者IP地址
            DI
                接收者IP地址
            Res
                全是0, 用于填充
            Ptc
                协议号, 17是UDP
            Len
                整个UDP帧长度
            若结果为全0, 则校验和置为全1! 其他按照正常校验和处理即可
        Data 
            数据段
    TCP
        字节流传输
            数据字节编号, 但是起始编号随机
            滑动窗口机制, 发送数据量以窗口大小为单位, 并非应用层消息
        面向连接
            因为有连接, 所以使用的不仅仅是端口, 而是套接口!
            IP和端口标识一个套接口, 两个套接口和协议的五元组标识一个连接
            通过连接建立, 管理, 释放进行可靠的面向连接服务
            建立连接, 三次握手
                主机1->主机2 SYN(Seq=x)
                主机2->主机1 SYN(Seq=y, Ack=x+1)
                主机1->主机2 Data(Seq=x+1, Ack=y+1)
                此时完成初始序列号, 窗口大小, MSS尺寸等协商并分配好资源
                MTU=IP头长+TCP头长+MSS, MSS在可选项Opt里
                若主机1和2同时向对方请求连接, 则只有一个TCP会建立起来
                SYN发出即启动定时器, 定时器清零还没响应, 则放弃连接, 连接失败
            断开连接, 对称释放
                主机1->主机2 FIN 
                主机2->主机1 ACK&FIN
                主机1->主机2 ACK
                为防止半连接, 用定时器计算FIN生存期的二倍, 超时直接断开连接
                对方因为收不到回复, 则超时之后也会断开
                主机发送FIN之后, 就不再发送Data
            与连接相关的定时器
                保持存活定时器(Keep Alive Timer)
                    收到信息之后启动, 超时则发送数据段检测闲置连接是否存在
                    有响应则重启定时器
                    无响应则断开
                闲置定时器(Queit Timer)
                    断开连接后启动, 超时之前不能使用该端口
                    断开连接后防止还有数据段在路上, 设定计时器防止立即重复使用
        流量控制与拥塞控制
            流量控制是对收发双方的, 拥塞控制是对整个网络的
            流量控制
                傻瓜窗口症状
                    发送方
                        每次接收应用层数据, 直接发送(指小数据)
                    接收方
                        TCP缓冲区满, 发送控制发送窗口更新0的数据
                        因应用程序要求, 读一个小数据, 缓冲区空出来一小块
                        发送控制发送窗口更新小的数据, 接收之后窗口又满了
                    循环开始
                    解决方法
                        Nagle算法
                            禁止发送方发太小数据段, 有一定数量再发
                        Clark算法
                            禁止接收方发太小窗口更新, 有一定可用空间再发
                与流量控制相关的定时器
                    持续定时器(Persistence Timer)
                        极少见情况, 防止死锁
                        接收方发送窗口更新0的数据, 发送方收到
                        接收方发送更新窗口的数据, 路上丢失
                        发送方和接收方都在等对方发送, 死锁
                        解决方法
                            接收方收到窗口更新0的数据时, 启动持续定时器
                            超时还没收到, 则发送1字节试探数据段
                            根据收到的窗口更新判断重新计时还是发送数据
            拥塞控制
                分组在路由器排队延迟和丢包概率增大
                主机大量重传分组
                网络有效吞吐量下降
                正反馈数据越来越多, 恶性循环
                通过发送端数据超时判断是否拥塞
                解决方法
                    维护RWND和CWND
                    RWND
                        RWND根据目前可用接收端缓存大小决定到达最新窗口值
                        接收端需要把窗口值放在TCP头标WS段发给发送端
                    CWND
                        CWND根据发送端自身估计的网络拥塞程度设定的窗口值
                    SWND
                        SWND由min(RWND, CWND)决定
                控制算法(慢启动+拥塞避免机制, 最早的Tahoe算法)
                    慢启动
                        初始情况, CWND初始为该连接最大数据段长度MSS
                        发送端发送一个最大数据段, 确认后则将CWND加倍
                        以此类推, 直至发送端认为丢包或已达到RWND大小或CWND增长到SSTHRESH
                        这个认为需要兼顾拥塞和流量控制
                        即观察丢包情况和接收端确认包
                    拥塞避免
                        拥塞窗口增长到SSTHRESH开始
                        每次发送端将CWND+MSS后发送数据段, 同时SSTHRESH增加
                        以此类推
                        若超时, 则将CWND减半作为新的SSTHRESH, CWND变成MSS
                        重复
                    当CWND<SSTHRESH时, 慢启动
                    当CWND>=SSTHRESH时, 拥塞避免
                    只要丢包就乘法减小, 拥塞避免加法增大
                快速重传算法
                    发送端收到三个连续重复的ACK确认时, 则认定丢包
                    此时不必等重传定时器, 立即重传
                快速恢复算法
                    判定丢包时, 乘法减小
                    SSTHRESH减半, 发送端把CWND直接设置为SSTHRESH
                    直接进入拥塞避免算法, CWND缓慢增大
                Tahoe算法
                    慢启动, 拥塞避免, 快速重传算法
                Reno算法
                    慢启动, 拥塞避免, 快速重传算法, 快速恢复算法
        与可靠性保证相关的定时器
            重传定时器(Retransmission Timer)
                发送方发送数据同时启动, 超时之前被确认则关闭定时器
                否则重传数据段
                超时间隔Timeout设置方法(太长等待时间长, 太短重复不必要数据)
                    Jacobson
                        性能测试, 动态调整
                        对每条链接, TCP保存变量RTT
                        RTT_{n}=a*RTT_{n-1}+(1-a)M_{n}
                        a是修正因子, M是新增的往返时延(a一般是7/8)
                        D_{n}=b*D_{n-1}+(1-b)|RTT_{n-1}-M_{n}|
                        b是另一个修正因子(可能和前者不一样), D是超时间隔
                        Timeout_{n}=RTT_{n}+4D_{n}
                    Karn
                        对已重发数据无需修改RTT
                        在传输失败时将超时时间Timeout加倍
                            若成功, 则继续Jacobson算法
                            若超时, 则断开TCP
            ACK延时定时器(Delayed ACK Timer)
                TCP的捎带确认功能
                对于那些不需要立即回复的数据的确认
                把ACK打包在下一次要发的数据中
            选择确认SACK
                接收端收到不连续的数据段, 可能因为某些数据段丢失
                若数据段不在窗口内, 丢弃
                若数据段在窗口之内, 则先收下数据, 发送这些数据的确认帧
                发送端不再重复发送已收到的数据段
            全双工
                连接上是两个方向TCP数据流, 两组编号相互独立
        五个定时器
            保持存活定时器(Keep Alive Timer)
                定期检测连接存在
            闲置定时器(Queit Timer)
                端口重新连接有冷却时间
            持续定时器(Persistence Timer)
                防均等待死锁
            重传定时器(Retransmission Timer)
                丢包的解决方案
            ACK延时定时器(Delayed ACK Timer)
                捎带应答
        两个算法
            快速恢复算法(Reno算法)
                丢包后的拥塞控制
            快速重传算法
                可靠性重传
        帧格式
            2B 2B 4B  4B  4bit 6bit 6bit 2B 2B  2B 0<=40B  nB
            SP DP Seq Ack Len  Res  Ctrl WS Cks UP Opt+Pad Data
        SP 
            源端口号
        DP 
            目的端口号
        Seq
            将要发送的数据段的字节编号
        Ack 
            期待收到的数据段的字节编号
        Len 
            整个TCP帧头长度, 单位是4字节, 范围5到15, 即20到60B
        Res
            全是0, 用于填充
        Ctrl
            控制指示, URG紧急, ACK确认, PSH提交, RST重连, SYN同步, FIN断开
        WS
            窗口大小, 用于流量控制和拥塞控制
        Cks
            整个TCP数据帧的16位校验和
            计算时需要添加一个虚的伪IP头标进行
            伪头标
                4B 4B 1B  1B  2B
                SI DI Res Ptc Len
            SI
                发送者IP地址
            DI
                接收者IP地址
            Res
                全是0, 用于填充
            Ptc
                协议号, 06是TCP
            Len
                整个TCP帧长度
            若结果为全0, 则校验和置为全1! 其他按照正常校验和处理即可
        UP
            紧急指针, 指向紧急数据的最后一个字节, 仅在URG为1有效
        Opt+Pad
            可选项, 如果有则必须填充到4字节的整数倍
            用于提供排错, 测量, 安全等措施
            增加功能, 但是增加了路由器开销, 不过这部分很少用
        Data 
            数据段

8.5 Berkeley Socket
    Socket原语
        SOCKET(建立套接字)
            创建新通信端点的连接
        BIND(套接字绑定端口)
            本地地址关联到套接字上
        LISTEN(主动变被动服务器, 开始侦听端口有无连接请求)
            宣布愿意接受连接, 给出等待连接的队列大小
        ACCEPT(接受侦听的连接请求, 给它新的套接字, 原来的套接字还在侦听)
            阻塞调用方, 直到有人企图连接
        CONNECT(发送连接请求)
            主动尝试建立连接
        SEND(发)
            从连接上发送数据
        RECV(收)
            从连接上接收数据
        CLOSE(关闭套接字)
            释放连接
    socket在应用层, 端口在传输层
    Internet中, socket以客户-服务器为模型提供服务
    客户与服务器作用非对称, 因此编码不同
    服务进程优先于客户请求启动, 只要系统运行就存在, 直到终止
    客户需知道服务器的IP和端口信息
    ~表示可以上下游动
    TCP
        服务器          客户
        ~socket()       ~socket()
        ~bind()          
        ~listen()  
        accept()      
                        connect()
        read()          
                        write()
                        read()
        write()
        ~close()        ~close()
    UDP
        服务器          客户
        ~socket()       ~socket()
        ~bind()         ~bind()
        recvfrom()
                        sendto()
                        recvfrom()
        sendto()
        ~close()        ~close()
